location,code
A.0000000000000000.Gaia,"import NonFungibleToken from 0x1d7e57aa55817448

// Gaia
// NFT an open NFT standard!
//
pub contract Gaia: NonFungibleToken {

    // Events
    //
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event TemplateCreated(id: UInt64, metadata: {String:String})
    pub event SetCreated(setID: UInt64, name: String, description: String, website: String, imageURI: String, creator: Address, marketFee: UFix64)
    pub event SetAddedAllowedAccount(setID: UInt64, allowedAccount: Address)
    pub event SetRemovedAllowedAccount(setID: UInt64, allowedAccount: Address)
    pub event TemplateAddedToSet(setID: UInt64, templateID: UInt64)
    pub event TemplateLockedFromSet(setID: UInt64, templateID: UInt64, numNFTs: UInt64)
    pub event SetLocked(setID: UInt64)
    pub event Minted(assetID: UInt64, templateID: UInt64, setID: UInt64, mintNumber: UInt64)

    // Named Paths
    //
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    // Variable size dictionary of Play structs
    access(self) var templateDatas: {UInt64: Template}

    // Variable size dictionary of SetData structs
    access(self) var setDatas: {UInt64: SetData}

    // Variable size dictionary of Set resources
    access(self) var sets: @{UInt64: Set}

    // totalSupply
    // The total number of Gaia that have been minted
    //
    pub var totalSupply: UInt64


    // The ID that is used to create Templates. 
    // Every time a Template is created, templateID is assigned 
    // to the new Template's ID and then is incremented by 1.
    pub var nextTemplateID: UInt64


    // The ID that is used to create Sets. Every time a Set is created
    // setID is assigned to the new set's ID and then is incremented by 1.
    pub var nextSetID: UInt64

    // -----------------------------------------------------------------------
    // Gaia contract-level Composite Type definitions
    // -----------------------------------------------------------------------
    // These are just *definitions* for Types that this contract
    // and other accounts can use. These definitions do not contain
    // actual stored values, but an instance (or object) of one of these Types
    // can be created by this contract that contains stored values.
    // -----------------------------------------------------------------------

    // Template is a Struct that holds metadata associated 
    // with a specific NFT template
    // NFTs will all reference a single template as the owner of
    // its metadata. The templates are publicly accessible, so anyone can
    // read the metadata associated with a specific template ID
    //
    pub struct Template {

        // The unique ID for the template
        pub let templateID: UInt64

        // Stores all the metadata about the template as a string mapping
        // This is not the long term way NFT metadata will be stored.
        pub let metadata: {String: String}

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: ""New Template metadata cannot be empty""
            }
            self.templateID = Gaia.nextTemplateID
            self.metadata = metadata

            // Increment the ID so that it isn't used again
            Gaia.nextTemplateID = Gaia.nextTemplateID + 1 as UInt64

            emit TemplateCreated(id: self.templateID, metadata: metadata)
        }
    }

    // A Set is a grouping of Templates that have occured in the real world
    // that make up a related group of collectibles, like sets of Magic cards.
    // A Template can exist in multiple different sets. 
    // SetData is a struct that is stored in a field of the contract.
    // Anyone can query the constant information
    // about a set by calling various getters located 
    // at the end of the contract. Only the admin has the ability 
    // to modify any data in the private Set resource.
    //
    pub struct SetData {

        // Unique ID for the Set
        pub let setID: UInt64

        // Name of the Set
        pub let name: String

        // Brief description of the Set
        pub let description: String

        // Set cover image
        pub let imageURI: String

        // Set website url
        pub let website: String

        // Set creator account address
        pub let creator: Address
        
        // Accounts allowed to mint
        access(self) let allowedAccounts: [Address]

        pub fun returnAllowedAccounts(): [Address] {
            return self.allowedAccounts
        }

        // Set marketplace fee
        pub let marketFee: UFix64

        init(name: String, description: String, website: String, imageURI: String, creator: Address, marketFee: UFix64) {
            pre {
                name.length > 0: ""New set name cannot be empty""
                description.length > 0: ""New set description cannot be empty""
                imageURI.length > 0: ""New set imageURI cannot be empty""
                creator != nil: ""Creator must not be nil""
                marketFee >= 0.0 && marketFee <= 0.15: ""Market fee must be a number between 0.00 and 0.15""
            }
            
            self.setID = Gaia.nextSetID
            self.name = name
            self.description = description
            self.website = website
            self.imageURI = imageURI
            self.creator = creator
            self.allowedAccounts = [creator, Gaia.account.address]
            self.marketFee = marketFee

            // Increment the setID so that it isn't used again
            Gaia.nextSetID = Gaia.nextSetID + 1 as UInt64
            emit SetCreated(setID: self.setID, name: name, description: description, website: website, imageURI: imageURI, creator: creator, marketFee: marketFee)
        }

        pub fun addAllowedAccount(account: Address) {
            pre {
                !self.allowedAccounts.contains(account): ""Account already allowed""
            }

            self.allowedAccounts.append(account)

            emit SetAddedAllowedAccount(setID: self.setID, allowedAccount: account)
        }

        pub fun removeAllowedAccount(account: Address) {
            pre {
                self.creator != account: ""Cannot remove set creator""
                self.allowedAccounts.contains(account): ""Not in allowed accounts""
            }

            var index = 0
            for acc in self.allowedAccounts {
                if (acc == account) {
                    self.allowedAccounts.remove(at: index)
                    break
                }
                index = index + 1
            }

            emit SetRemovedAllowedAccount(setID: self.setID, allowedAccount: account)
        }
    }

    // Set is a resource type that contains the functions to add and remove
    // Templates from a set and mint NFTs.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods.
    //
    // The admin can add Templates to a Set so that the set can mint NFTs
    // that reference that template data.
    // The NFTs that are minted by a Set will be listed as belonging to
    // the Set that minted it, as well as the Template it references.
    // 
    // Admin can also lock Templates from the Set, meaning that the lockd
    // Template can no longer have NFTs minted from it.
    //
    // If the admin locks the Set, no more Templates can be added to it, but 
    // NFTs can still be minted.
    //
    // If lockAll() and lock() are called back-to-back, 
    // the Set is closed off forever and nothing more can be done with it.
    pub resource Set {

        // Unique ID for the set
        pub let setID: UInt64

        // Array of templates that are a part of this set.
        // When a template is added to the set, its ID gets appended here.
        // The ID does not get removed from this array when a templates is locked.
        pub var templates: [UInt64]

        // Map of template IDs that Indicates if a template in this Set can be minted.
        // When a templates is added to a Set, it is mapped to false (not locked).
        // When a templates is locked, this is set to true and cannot be changed.
        pub var lockedTemplates: {UInt64: Bool}

        // Indicates if the Set is currently locked.
        // When a Set is created, it is unlocked 
        // and templates are allowed to be added to it.
        // When a set is locked, templates cannot be added.
        // A Set can never be changed from locked to unlocked,
        // the decision to lock a Set it is final.
        // If a Set is locked, templates cannot be added, but
        // NFTs can still be minted from templates
        // that exist in the Set.
        pub var locked: Bool

        // Mapping of Template IDs that indicates the number of NFTs 
        // that have been minted for specific Templates in this Set.
        // When a NFT is minted, this value is stored in the NFT to
        // show its place in the Set, eg. 13 of 60.
        pub var numberMintedPerTemplate: {UInt64: UInt64}

        init(name: String, description: String, website: String, imageURI: String, creator: Address, marketFee: UFix64)
         {
            self.setID = Gaia.nextSetID
            self.templates = []
            self.lockedTemplates = {}
            self.locked = false
            self.numberMintedPerTemplate = {}
            // Create a new SetData for this Set and store it in contract storage
            Gaia.setDatas[self.setID] = SetData(name: name, description: description, website: website, imageURI: imageURI, creator: creator, marketFee: marketFee)
        }

        // addTemplate adds a template to the set
        //
        // Parameters: templateID: The ID of the template that is being added
        //
        // Pre-Conditions:
        // The template needs to be an existing template
        // The Set needs to be not locked
        // The template can't have already been added to the Set
        //
        pub fun addTemplate(templateID: UInt64) {
            pre {
                Gaia.templateDatas[templateID] != nil: ""Cannot add the Template to Set: Template doesn't exist.""
                !self.locked: ""Cannot add the template to the Set after the set has been locked.""
                self.numberMintedPerTemplate[templateID] == nil: ""The template has already beed added to the set.""
            }

            // Add the Play to the array of Plays
            self.templates.append(templateID)

            // Open the Play up for minting
            self.lockedTemplates[templateID] = false

            // Initialize the Moment count to zero
            self.numberMintedPerTemplate[templateID] = 0

            emit TemplateAddedToSet(setID: self.setID, templateID: templateID)
        }

        // addTemplates adds multiple templates to the Set
        //
        // Parameters: templateIDs: The IDs of the templates that are being added
        //
        pub fun addTemplates(templateIDs: [UInt64]) {
            for template in templateIDs {
                self.addTemplate(templateID: template)
            }
        }

        // retirePlay retires a Play from the Set so that it can't mint new Moments
        //
        // Parameters: playID: The ID of the Play that is being retired
        //
        // Pre-Conditions:
        // The Play is part of the Set and not retired (available for minting).
        // 
        pub fun lockTemplate(templateID: UInt64) {
            pre {
                self.lockedTemplates[templateID] != nil: ""Cannot lock the template: Template doesn't exist in this set!""
            }

            if !self.lockedTemplates[templateID]! {
                self.lockedTemplates[templateID] = true

                emit TemplateLockedFromSet(setID: self.setID, templateID: templateID, numNFTs: self.numberMintedPerTemplate[templateID]!)
            }
        }

        // lockAll lock all the templates in the Set
        // Afterwards, none of the locked templates will be able to mint new NFTs
        //
        pub fun lockAll() {
            for template in self.templates {
                self.lockTemplate(templateID: template)
            }
        }

        // lock() locks the Set so that no more Templates can be added to it
        //
        // Pre-Conditions:
        // The Set should not be locked
        pub fun lock() {
            if !self.locked {
                self.locked = true
                emit SetLocked(setID: self.setID)
            }
        }

        // mintNFT mints a new NFT and returns the newly minted NFT
        // 
        // Parameters: templateID: The ID of the Template that the NFT references
        //
        // Pre-Conditions:
        // The Template must exist in the Set and be allowed to mint new NFTs
        //
        // Returns: The NFT that was minted
        // 
        pub fun mintNFT(templateID: UInt64): @NFT {
            pre {
                self.lockedTemplates[templateID] != nil: ""Cannot mint the NFT: This template doesn't exist.""
                !self.lockedTemplates[templateID]!: ""Cannot mint the NFT from this template: This template has been locked.""
            }

            // Gets the number of NFTs that have been minted for this Template
            // to use as this NFT's serial number
            let numInTemplate = self.numberMintedPerTemplate[templateID]!

            // Mint the new moment
            let newNFT: @NFT <- create NFT(mintNumber: numInTemplate + 1 as UInt64,
                                              templateID: templateID,
                                              setID: self.setID)

            // Increment the count of Moments minted for this Play
            self.numberMintedPerTemplate[templateID] = numInTemplate + 1 as UInt64

            return <-newNFT
        }

        // batchMintNFT mints an arbitrary quantity of NFTs 
        // and returns them as a Collection
        //
        // Parameters: templateID: the ID of the Template that the NFTs are minted for
        //             quantity: The quantity of NFTs to be minted
        //
        // Returns: Collection object that contains all the NFTs that were minted
        //
        pub fun batchMintNFT(templateID: UInt64, quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintNFT(templateID: templateID))
                i = i + 1 as UInt64
            }

            return <-newCollection
        }
    }


    pub struct NFTData {

        // The ID of the Set that the Moment comes from
        pub let setID: UInt64

        // The ID of the Play that the Moment references
        pub let templateID: UInt64

        // The place in the edition that this Moment was minted
        // Otherwise know as the serial number
        pub let mintNumber: UInt64

        init(setID: UInt64, templateID: UInt64, mintNumber: UInt64) {
            self.setID = setID
            self.templateID = templateID
            self.mintNumber = mintNumber
        }

    }

    // NFT
    // A Flow Asset as an NFT
    //
    pub resource NFT: NonFungibleToken.INFT {
        // The token's ID
        pub let id: UInt64
        // Struct of NFT metadata
        pub let data: NFTData

        // initializer
        //
        init(mintNumber: UInt64, templateID: UInt64, setID: UInt64) {
            // Increment the global Moment IDs
            Gaia.totalSupply = Gaia.totalSupply + 1 as UInt64

            self.id = Gaia.totalSupply

            // Set the metadata struct
            self.data = NFTData(setID: setID, templateID: templateID, mintNumber: mintNumber)

            emit Minted(assetID: self.id, templateID: templateID, setID: self.data.setID, mintNumber: self.data.mintNumber)
        }
    }

    // Admin is a special authorization resource that 
    // allows the owner to perform important functions to modify the 
    // various aspects of the Templates, Sets, and NFTs
    //
    pub resource Admin {

        // createTemplate creates a new Template struct 
        // and stores it in the Templates dictionary in the TopShot smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {""Name"": ""John Doe"", ""DoB"": ""4/14/1990""}
        //
        // Returns: the ID of the new Template object
        //
        pub fun createTemplate(metadata: {String: String}): UInt64 {
            // Create the new Template
            var newTemplate = Template(metadata: metadata)
            let newID = newTemplate.templateID

            // Store it in the contract storage
            Gaia.templateDatas[newID] = newTemplate

            return newID
        }

         pub fun createTemplates(templates: [{String: String}], setID: UInt64, authorizedAccount: Address){
             
              var templateIDs: [UInt64] = []
            for metadata in templates {
                var ID = self.createTemplate(metadata: metadata)
                templateIDs.append(ID)
            }
            self.borrowSet(setID: setID, authorizedAccount: authorizedAccount).addTemplates(templateIDs: templateIDs)
        }

        // createSet creates a new Set resource and stores it
        // in the sets mapping in the contract
        //
        // Parameters: name: The name of the Set
        //
        pub fun createSet(name: String, description: String, website: String, imageURI: String, creator: Address, marketFee: UFix64) {
            // Create the new Set
            var newSet <- create Set(name: name, description: description, website: website, imageURI: imageURI, creator: creator, marketFee: marketFee)
            // Store it in the sets mapping field
            Gaia.sets[newSet.setID] <-! newSet
        }

        // borrowSet returns a reference to a set in the contract
        // so that the admin can call methods on it
        //
        // Parameters: setID: The ID of the Set that you want to
        // get a reference to
        //
        // Returns: A reference to the Set with all of the fields
        // and methods exposed
        //
        pub fun borrowSet(setID: UInt64, authorizedAccount: Address): &Set {
            pre {
                Gaia.sets[setID] != nil: ""Cannot borrow Set: The Set doesn't exist""
                Gaia.setDatas[setID]!.returnAllowedAccounts().contains(authorizedAccount): ""Account not authorized""
            }
            
            // Get a reference to the Set and return it
            // use `&` to indicate the reference to the object and type
            return &Gaia.sets[setID] as &Set
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // This is the interface that users can cast their Gaia Collection as
    // to allow others to deposit Gaia into their Collection. It also allows for reading
    // the details of Gaia in the Collection.
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowGaiaNFT(id: UInt64): &Gaia.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    ""Cannot borrow GaiaAsset reference: The ID of the returned reference is incorrect""
            }
        }
    }

    // Collection
    // A collection of GaiaAsset NFTs owned by an account
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        //
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        // withdraw
        // Removes an NFT from the collection and moves it to the caller
        //
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(""missing NFT"")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: ids: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn NFTs
        //
        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()
            
            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            
            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit
        // Takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Gaia.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs
        // Returns an array of the IDs that are in the collection
        //
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT
        // Gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return &self.ownedNFTs[id] as &NonFungibleToken.NFT
        }

        // borrowGaiaNFT
        // Gets a reference to an NFT in the collection as a GaiaAsset,
        // exposing all of its fields (including the typeID).
        // This is safe as there are no functions that can be called on the GaiaAsset.
        //
        pub fun borrowGaiaNFT(id: UInt64): &Gaia.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
                return ref as! &Gaia.NFT
            } else {
                return nil
            }
        }

        // destructor
        destroy() {
            destroy self.ownedNFTs
        }

        // initializer
        //
        init () {
            self.ownedNFTs <- {}
        }
    }

    // createEmptyCollection
    // public function that anyone can call to create a new empty collection
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // getAllTemplates returns all the plays in topshot
    //
    // Returns: An array of all the plays that have been created
    pub fun getAllTemplates(): [Gaia.Template] {
        return Gaia.templateDatas.values
    }

    // getTemplateMetaData returns all the metadata associated with a specific Template
    // 
    // Parameters: templateID: The id of the Template that is being searched
    //
    // Returns: The metadata as a String to String mapping optional
    pub fun getTemplateMetaData(templateID: UInt64): {String: String}? {
        return self.templateDatas[templateID]?.metadata
    }

    // getTemplateMetaDataByField returns the metadata associated with a 
    //                        specific field of the metadata
    //                        Ex: field: ""Name"" will return something
    //                        like ""John Doe""
    // 
    // Parameters: templateID: The id of the Template that is being searched
    //             field: The field to search for
    //
    // Returns: The metadata field as a String Optional
    pub fun getTemplateMetaDataByField(templateID: UInt64, field: String): String? {
        // Don't force a revert if the playID or field is invalid
        if let template = Gaia.templateDatas[templateID] {
            return template.metadata[field]
        } else {
            return nil
        }
    }

    // getSetName returns the name that the specified Set
    //            is associated with.
    // 
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The name of the Set
    pub fun getSetName(setID: UInt64): String? {
        // Don't force a revert if the setID is invalid
        return Gaia.setDatas[setID]?.name
    }

    pub fun getSetMarketFee(setID: UInt64): UFix64? {
        // Don't force a revert if the setID is invalid
        return Gaia.setDatas[setID]?.marketFee
    }
    
    pub fun getSetImage(setID: UInt64): String? {
        // Don't force a revert if the setID is invalid
        return Gaia.setDatas[setID]?.imageURI
    } 

    pub fun getSetInfo(setID: UInt64): SetData? {
        // Don't force a revert if the setID is invalid
        return Gaia.setDatas[setID]
    } 

    // getSetIDsByName returns the IDs that the specified Set name
    //                 is associated with.
    // 
    // Parameters: setName: The name of the Set that is being searched
    //
    // Returns: An array of the IDs of the Set if it exists, or nil if doesn't
    pub fun getSetIDsByName(setName: String): [UInt64]? {
        var setIDs: [UInt64] = []

        // Iterate through all the setDatas and search for the name
        for setData in Gaia.setDatas.values {
            if setName == setData.name {
                // If the name is found, return the ID
                setIDs.append(setData.setID)
            }
        }

        // If the name isn't found, return nil
        // Don't force a revert if the setName is invalid
        if setIDs.length == 0 {
            return nil
        } else {
            return setIDs
        }
    }

    // getTemplatesInSet returns the list of Template IDs that are in the Set
    // 
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: An array of Template IDs
    pub fun getTemplatesInSet(setID: UInt64): [UInt64]? {
        // Don't force a revert if the setID is invalid
        return Gaia.sets[setID]?.templates
    }

    // isSetTemplateLocked returns a boolean that indicates if a Set/Template combo
    //                  is locked.
    //                  If an template is locked, it still remains in the Set,
    //                  but NFTs can no longer be minted from it.
    // 
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: Boolean indicating if the template is locked or not
    pub fun isSetTemplateLocked(setID: UInt64, templateID: UInt64): Bool? {
        // Don't force a revert if the set or play ID is invalid
        // Remove the set from the dictionary to get its field
        if let setToRead <- Gaia.sets.remove(key: setID) {

            // See if the Play is retired from this Set
            let locked = setToRead.lockedTemplates[templateID]

            // Put the Set back in the contract storage
            Gaia.sets[setID] <-! setToRead

            // Return the retired status
            return locked
        } else {

            // If the Set wasn't found, return nil
            return nil
        }
    }

    // isSetLocked returns a boolean that indicates if a Set
    //             is locked. If it's locked, 
    //             new Plays can no longer be added to it,
    //             but NFTs can still be minted from Templates the set contains.
    // 
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: Boolean indicating if the Set is locked or not
    pub fun isSetLocked(setID: UInt64): Bool? {
        // Don't force a revert if the setID is invalid
        return Gaia.sets[setID]?.locked
    }

    // getTotalMinted return the number of NFTS that have been 
    //                        minted from a certain set and template.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             templateID: The id of the Template that is being searched
    //
    // Returns: The total number of NFTs 
    //          that have been minted from an set and template
    pub fun getTotalMinted(setID: UInt64, templateID: UInt64): UInt64? {
        // Don't force a revert if the Set or play ID is invalid
        // Remove the Set from the dictionary to get its field
        if let setToRead <- Gaia.sets.remove(key: setID) {

            // Read the numMintedPerPlay
            let amount = setToRead.numberMintedPerTemplate[templateID]

            // Put the Set back into the Sets dictionary
            Gaia.sets[setID] <-! setToRead

            return amount
        } else {
            // If the set wasn't found return nil
            return nil
        }
    }

    // fetch
    // Get a reference to a GaiaAsset from an account's Collection, if available.
    // If an account does not have a Gaia.Collection, panic.
    // If it has a collection but does not contain the itemID, return nil.
    // If it has a collection and that collection contains the itemID, return a reference to that.
    //
    pub fun fetch(_ from: Address, itemID: UInt64): &Gaia.NFT? {
        let collection = getAccount(from)
            .getCapability(Gaia.CollectionPublicPath)
            .borrow<&Gaia.Collection{Gaia.CollectionPublic}>()
            ?? panic(""Couldn't get collection"")
        // We trust Gaia.Collection.borowGaiaAsset to get the correct itemID
        // (it checks it before returning it).
        return collection.borrowGaiaNFT(id: itemID)
    }
    
    // checkSetup
    // Get a reference to a GaiaAsset from an account's Collection, if available.
    // If an account does not have a Gaia.Collection, returns false.
    // If it has a collection, return true.
    //
    pub fun checkSetup(_ address: Address): Bool {
        return getAccount(address)
        .getCapability<&{Gaia.CollectionPublic}>(Gaia.CollectionPublicPath)
        .check()
    }

    // initializer
    //
    init() {
        // Set our named paths
        //FIXME: REMOVE SUFFIX BEFORE RELEASE
        self.CollectionStoragePath = /storage/GaiaCollection001
        self.CollectionPublicPath = /public/GaiaCollection001

        // Initialize contract fields
        self.templateDatas = {}
        self.setDatas = {}
        self.sets <- {}
        self.nextTemplateID = 1
        self.nextSetID = 1
        self.totalSupply = 0

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.CollectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Put the Minter in storage
        self.account.save<@Admin>(<- create Admin(), to: /storage/GaiaAdmin)
    }
}
"
A.0000000000000000.GaiaFee,"// Gaia Fees
//
// Simple fee manager
//
pub contract GaiaFee {

    pub let commonFeeManagerStoragePath: StoragePath

    pub event SellerFeeChanged(value: UFix64)
    pub event BuyerFeeChanged(value: UFix64)
    pub event FeeAddressUpdated(label: String, address: Address)

    access(self) var feeAddresses: {String:Address}

    // Seller fee [0..1)
    pub var sellerFee: UFix64

    // BuyerFee fee [0..1)
    pub var buyerFee: UFix64

    pub resource Manager {
        pub fun setSellerFee(_ fee: UFix64) {
            GaiaFee.sellerFee = fee
            emit SellerFeeChanged(value: GaiaFee.sellerFee)
        }

        pub fun setBuyerFee(_ fee: UFix64) {
            GaiaFee.buyerFee = fee
            emit BuyerFeeChanged(value: GaiaFee.buyerFee)
        }

        pub fun setFeeAddress(_ label: String, address: Address) {
            GaiaFee.feeAddresses[label] = address
            emit FeeAddressUpdated(label: label, address: address)
        }
    }

    init() {
        self.sellerFee = 0.05 
        emit SellerFeeChanged(value: GaiaFee.sellerFee)
        self.buyerFee = 0.0 // Gaia Buyer Fee
        emit BuyerFeeChanged(value: GaiaFee.buyerFee)

        self.feeAddresses = {}

        self.commonFeeManagerStoragePath = /storage/commonFeeManager
        self.account.save(<- create Manager(), to: self.commonFeeManagerStoragePath)
    }

    pub fun feeAddress(): Address {
        return self.feeAddresses[""gaia""] ?? self.account.address
    }

    pub fun feeAddressByName(_ label: String): Address {
        return self.feeAddresses[label] ?? self.account.address
    }

    pub fun addressMap(): {String:Address} {
        return GaiaFee.feeAddresses
    }
}
"
A.0000000000000000.GaiaNFT,"// SPDX-License-Identifier: UNLICENSED

/*

  GaiaNFT

  This contract encompasses the minting and related administration logic for
  NFTs hosted by Gaia (https://ongaia.com/).

  NFTs are minted with references to Template structs. Templates allow a
  GaiaNFT Admin to reveal the NFT metadata after it has been minted (and 
  probably bought). In order to assure collectors that the metadata was
  decided pre-mint and not changed before reveal, Admins must mint metadata
  with a fixed sized byte array checksum. The revealed metadata should
  provide a unique hash (by implementing the {GaiaMetadata} interface) that
  can be used to verify the checksum.

  This setup allows for any custom structs to act as metadata for the NFT, 
  as long as they implement GaiaMetadata to 
  - allow checksum reveals
  - allow third party services to rely on well-known metadata standards to 
    properly view the NFT.
  - provide a standard Display interface for wallets
  - provide a {string: string} representation of the metadata for reporting

  Gaia admins may want to ""drop"" multiple NFTs all at the same time. This
  can be coordinated with Set resources, defined in this contract. Sets must
  be configured with a list of Templates from which to mint NFTs with. No NFTs
  can be minted until the Set is Locked, and only those NFTs which were
  specified pre-lock are allowed to be minted from that Set. Using SetManager
  resources, Admins can issue modification privileges for each set individually.

  The general workflow would look as follows.
  1.  This contract is deployed with a singleton Admin resource
  2.  The Admin creates as many Sets as needed
  3.  Accounts responsible for managing sets initialze a GaiaAccount resource 
      so they may accept SetManager privileges
  4.  The Admin creates SetManager resources (at least one per Set) and
      distributes them to the appropriate GaiaAccounts
  5.  For each independent Set, A SetManager configures the Set with Templates
  6.  A SetManager locks the Set as a commitment to limit the drop to the 
      configured Templates
  7.  A SetManager mints NFTs to any account's collection they choose.
  8.  A Set is marked as Completed once all NFTs have been minted from that Set

 */

import NonFungibleToken from ""../../../core/contract/NonFungibleToken.cdc""
import MetadataViews from ""../../../core/contract/MetadataViews.cdc""
import Crypto

pub contract GaiaNFT: NonFungibleToken {

  // Events
  //
  // This contract is initialized
  pub event ContractInitialized()

  // NFT is minted
  pub event NFTMinted(
    nftId: UInt64,
    setId: UInt64,
    templateId: UInt64,
    displayName: String,
    displayDescription: String,
    displayURI: String,
    creator: Address,
  )

  // NFT is withdrawn from a collection
  pub event Withdraw(id: UInt64, from: Address?)

  // NFT is deposited from a collection
  pub event Deposit(id: UInt64, to: Address?)

  // NFT is destroyed
  pub event NFTDestroyed(id: UInt64)

  // NFT template metadata is revealed
  pub event NFTRevealed(
    nftId: UInt64,
    setId: UInt64,
    templateId: UInt64,
    displayName: String,
    displayDescription: String,
    displayURI: String,
    metadata: {String: String},
    templateType: Type
  )

  // Set has been created
  pub event SetCreated(setId: UInt64, name: String)

  // Set has been marked Locked
  pub event SetLocked(setId: UInt64, numTemplates: UInt64)

  // Set has started Minting
  pub event SetMinting(setId: UInt64)

  // Set has finished Minting and is now in the Complete stage
  pub event SetComplete(setId: UInt64)

  // SetManager created
  pub event SetManagerCreated(
    setManagerId: UInt64,
    setId: UInt64,
    role: UInt8
  )

  // SetManager assigned
  pub event SetManagerAssigned(
    setManagerId: UInt64,
    setId: UInt64,
    account: Address?
  )

  // SetManager removed
  pub event SetManagerRemoved(
    setManagerId: UInt64,
    setId: UInt64,
    account: Address?
  )

  // SetManager revoked
  pub event SetManagerRevoked(
    setManagerId: UInt64
  )

  // SetManager unrevoked
  pub event SetManagerUnrevoked(
    setManagerId: UInt64
  )

  // Paths
  //
  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath 
  pub let CollectionPrivatePath: PrivatePath
  pub let AdminStoragePath: StoragePath
  pub let GaiaAccountPublicPath: PublicPath
  pub let GaiaAccountPath: StoragePath

  // Total NFT supply
  pub var totalSupply: UInt64

  // Dictionary mapping from set IDs to Set resources
  access(self) var sets: @{UInt64: Set}
  
  // Total number of SetManager resources created
  pub var setManagerSupply: UInt64

  // Revoked SetManager ids
  pub var setManagerRevocations: {UInt64: Bool}

  // All GaiaNFT metadata can have custom definitions but must have the
  // following implemented in order to power all the features of the
  // Gaia NFT contract.
  pub struct interface GaiaMetadata {

    // Hash representation of implementing structs.
    pub fun hash(): [UInt8]

    // Representative Display
    pub fun display(): MetadataViews.Display

    // Representative {string: string} serialization
    pub fun repr(): {String: String}
    
    // MetadataViews compliant
    pub fun getViews(): [Type]
    pub fun resolveView(_ view: Type): AnyStruct?
  }

  // NFT
  //
  // Gaia NFTs are ""standard"" NFTs that implement MetadataViews and point
  // to a Template struct that give information about the NFTs metadata
  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

    // id is unique among all Gaia NFTs on Flow, ordered sequentially from 0
    pub let id: UInt64

    // setID and templateID help us locate the specific template in the
    // specific set which stores this NFTs metadata
    pub let setId: UInt64
    pub let templateId: UInt64

    // The creator of the NFT
    pub let creator: Address

    // Fetch the metadata Template represented by this NFT
    pub fun template(): {TemplateNFT} {
      return GaiaNFT.getTemplate(setId: self.setId, templateId: self.templateId)
    }

    // Proxy for MetadataViews.Resolver.getViews implemented by Template
    pub fun getViews(): [Type] {
      let template = self.template()
      return template.getViews()
    }

    // Proxy for MetadataViews.Resolver.resolveView implemented by Template
    pub fun resolveView(_ view: Type): AnyStruct? {
      let template = self.template()
      return template.resolveView(view)
    }

    // NFT needs to be told which Template it follows
    init(setId: UInt64, templateId: UInt64, creator: Address) {
      self.id = GaiaNFT.totalSupply
      GaiaNFT.totalSupply = GaiaNFT.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.creator = creator
      let defaultDisplay = self.template().defaultDisplay
      emit NFTMinted(
        nftId: self.id,
        setId: self.setId,
        templateId: self.templateId,
        displayName: defaultDisplay.name,
        displayDescription: defaultDisplay.description,
        displayURI: defaultDisplay.thumbnail.uri(),
        creator: self.creator
      )
    }

    // Emit NFTDestroyed when destroyed
    destroy() {
      emit NFTDestroyed(
        id: self.id,
      )
    }
  }

  // Collection
  //
  // Collections provide a way for collectors to store Gaia NFTs in their
  // Flow account. 

  // Exposing this interface allows external parties to inspect a Flow
  // account's GaiaNFT Collection and deposit NFTs
  pub resource interface CollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowGaiaNFT(id: UInt64): &NFT
  }

  pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

    // NFTs are indexed by its globally assigned id
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    // Deposit a GaiaNFT into the collection. Safe to assume id's are unique.
    pub fun deposit(token: @NonFungibleToken.NFT) {
      // Required to ensure this is a GaiaNFT
      let token <- token as! @GaiaNFT.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    // Withdraw an NFT from the collection.
    // Panics if NFT does not exist in the collection
    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs.containsKey(withdrawID)
          : ""NFT does not exist in collection.""
      }
      let token <- self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    // Return all the IDs from the collection.
    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    // Borrow a reference to the specified NFT
    // Panics if NFT does not exist in the collection
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs.containsKey(id)
          : ""NFT does not exist in collection.""
      }
      return &self.ownedNFTs[id] as &NonFungibleToken.NFT
    }

    // Borrow a reference to the specified NFT as a Gaia NFT.
    // Panics if NFT does not exist in the collection
    pub fun borrowGaiaNFT(id: UInt64): &NFT {
      pre {
        self.ownedNFTs.containsKey(id)
          : ""NFT does not exist in collection.""
      }
      let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
      return ref as! &NFT
    }

    // Return the MetadataViews.Resolver of the specified NFT
    // Panics if NFT does not exist in the collection
    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs.containsKey(id)
          : ""NFT does not exist in collection.""
      }
      let nft = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
      let gaiaNft = nft as! &NFT
      return gaiaNft
    }

    init() {
      self.ownedNFTs <- {}
    }

    // If the collection is destroyed, destroy the NFTs it holds, as well
    destroy() {
      destroy self.ownedNFTs
    }
  }

  // Anyone can make and store collections
  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // Set
  //
  // Sets are ultimately the things that construct the NFTs. In other words,
  // all NFTs must be minted as part of a set. 
  //
  // Sets also use Templates to allow creators to commit to group of NFTs
  // at once. After the Set has been configured with NFTs, the admin must lock
  // the set, disallowing any new templates to be added to the set. NFTs can 
  // only be minted after an admin has locked a set. This can help creators
  // provide guarantees about the scarcity of a set.
  //
  // You can generally expect Sets to have 1-1 correlations with ""drops""

  // Set statuses
  pub enum Status: UInt8 {

    // Sets start off as Open, which means Templates can still be configured
    pub case Open

    // Admins must lock Sets after configuring the Templates. Templates can
    // no longer be configured at this state. The set can now start minting.
    // Note that we cannot go straight from Open to Minting
    pub case Locked

    // The set has already minted at least one NFT and still has NFTs left to
    // mint.
    pub case Minting

    // The Set has completed minting all of its NFTs
    pub case Complete
  }

  // SetMinter
  //
  // Mint NFTs in a set
  pub resource interface SetMinter {
    pub var metadata: SetMetadata
    pub var minted: UInt64
    pub fun mint(templateId: UInt64, creator: Address): @NFT
  }

  pub resource Set: SetMinter {

    // Globally assigned id based on number of created Sets.
    pub let id: UInt64

    // Current status of Set
    pub var status: Status

    // Metadata for the Set
    pub var metadata: SetMetadata

    // Templates configured to be minted from this Set
    access(contract) var templates: [Template]

    // Number of NFTs that have minted from this Set
    pub var minted: UInt64

    // Add a new Template to the Set, only if the Set is Open
    pub fun addTemplate(template: Template) {
      pre {
        self.status == Status.Open : ""Set is not Open. It cannot be modified""
      }
      self.templates.append(template)
    }

    // Clear the configured Templates from this Set if the Set is still Open.
    // This is here in case any mistakes were made and the creator needs to
    // start over
    pub fun clearTemplates() {
      pre {
        self.status == Status.Open : ""Set is not Open. It cannot be modified""
      }
      self.templates = []
    }

    // Lock the Set if it is Open. This signals that this Set
    // will mint NFTs based only on the Templates configured in this Set.
    pub fun lock() {
      pre {
        self.status == Status.Open : ""Only an Open set can be locked.""
        self.templates.length > 0
          : ""Set must be configured with at least one Template.""
      }
      self.status = Status.Locked
      emit SetLocked(setId: self.id, numTemplates: UInt64(self.templates.length))
    }

    // Mint numToMint NFTs with the supplied creator attribute. The NFT will
    // be minted into the provided receiver
    pub fun mint(
      templateId: UInt64,
      creator: Address
    ): @NFT {
      pre {
        self.status != Status.Open
          : ""Set must be locked before it can start minting.""
        self.status != Status.Complete
          : ""Set has already completed minting.""
        templateId < UInt64(self.templates.length)
          : ""templateId does not exist in Set.""
        self.templates[templateId].mintID == nil
          : ""Template has already been marked as minted.""
      }
      if (self.status == Status.Locked) {
        self.status = Status.Minting
        emit SetMinting(setId: self.id)
      }
      let nft <-create NFT(
          setId: self.id,
          templateId: templateId,
          creator: creator
        )
      self.templates[templateId].markMinted(nftId: nft.id)
      self.minted = self.minted + 1
      if (self.minted == UInt64(self.templates.length)) {
        self.status = Status.Complete
        emit SetComplete(setId: self.id)
      }
      return <- nft
    }

    // Reveal a specified Template in a Set.
    pub fun revealTemplate(
      templateId: UInt64,
      metadata: {GaiaMetadata},
      salt: [UInt8]
    ) {
      pre {
        templateId < UInt64(self.templates.length)
          : ""templateId does not exist in Set.""
        self.templates[templateId].mintID != nil
          : ""Template has already been marked as minted.""
      }
      let template = &self.templates[templateId] as &Template
      template.reveal(metadata: metadata, salt: salt)

      let display = metadata.display()
      emit NFTRevealed(
        nftId: template.mintID!,
        setId: self.id,
        templateId: templateId,
        displayName: display.name,
        displayDescription: display.description,
        displayURI: display.thumbnail.uri(),
        metadata: metadata.repr(),
        templateType: template.metadata.getType()
      )
    }

    init(id: UInt64, metadata: SetMetadata) {
      self.id = id
      self.metadata = metadata

      self.status = Status.Open
      self.templates = []

      self.minted = 0
      emit SetCreated(setId: id, name: metadata.name)
    }
  }

  // Create and store a new Set. Return the id of the new Set.
  access(contract) fun createSet(metadata: SetMetadata): UInt64 {
    let newSet <- create Set(
      id: UInt64(GaiaNFT.sets.length),
      metadata: metadata
    )
    let setId = newSet.id
    GaiaNFT.sets[setId] <-! newSet
    return setId
  }

  // Number of sets created by contract
  pub fun setsCount(): Int{
    return GaiaNFT.sets.length
  }

  // Metadata for the Set
  pub struct SetMetadata {
    pub var name: String
    pub var description: String
    init(name: String, description: String) {
      self.name = name
      self.description = description
    }
  }

  // A summary report of a Set
  pub struct SetReport {
    pub let id: UInt64
    pub let status: Status
    pub let metadata: SetMetadata
    pub let numTemplates: Int
    pub let numMinted: UInt64
    init(
      id: UInt64,
      status: Status,
      metadata: SetMetadata,
      numTemplates: Int,
      numMinted: UInt64
    ) {
      self.id = id
      self.status = status
      self.metadata = metadata
      self.numTemplates = numTemplates
      self.numMinted = numMinted
    }
  }

  // Generate a SetReport for informational purposes (to be used with scripts)
  pub fun generateSetReport(setId: UInt64): SetReport {
    let setRef = &self.sets[setId] as &Set
    return SetReport(
      id: setId,
      status: setRef.status,
      metadata: setRef.metadata,
      numTemplates: setRef.templates.length,
      numMinted: setRef.minted
    )
  }

  // Template
  //
  // Templates are mechanisms for handling NFT metadata. These should ideally
  // have a one to one mapping with NFTs, with the assumption that NFTs are 
  // designed to be unique. Template allows the creator to commit to an NFTs
  // metadata without having to reveal the metadata itself. The constructor
  // accepts a byte array checksum. After construction, anyone with access
  // to this struct will be able to reveal the metadata, which must be any
  // struct which implements GaiaMetadata and MetadataViews.Resolver such that
  // SHA3_256(salt || metadata.hash()) == checksum.
  //
  // Templates can be seen as metadata managers for NFTs. As such, Templates
  // also implement the MetadataResolver interface to conform with standards.

  // Safe Template interface for anyone inspecting NFTs
  pub struct interface TemplateNFT {
    pub let defaultDisplay: MetadataViews.Display
    pub var metadata: {GaiaMetadata}?
    pub var mintID: UInt64?
    pub fun checksum(): [UInt8]
    pub fun salt(): [UInt8]?
    pub fun revealed(): Bool
    pub fun getViews(): [Type]
    pub fun resolveView(_ view: Type): AnyStruct?
  }

  pub struct Template: TemplateNFT {

    // checksum as described above
    access(self) let _checksum: [UInt8]

    // Default Display in case the Template has not yet been revealed
    pub let defaultDisplay: MetadataViews.Display

    // salt and metadata are optional so they can be revealed later, such that
    // SHA3_256(salt || metadata.hash()) == checksum
    access(self) var _salt: [UInt8]?
    pub var metadata: {GaiaMetadata}?

    // Convenience attribute to mark whether or not Template has minted NFT
    pub var mintID: UInt64?

    // Helper function to check if a proposed metadata and salt reveal would
    // produce the configured checksum in a Template
    pub fun validate(metadata: {GaiaMetadata}, salt: [UInt8]): Bool {
      let hash = String.encodeHex(
        HashAlgorithm.SHA3_256.hash(
          salt.concat(metadata.hash())
        )
      )
      let checksum = String.encodeHex(self.checksum())
      return hash == checksum
    }

    // Reveal template metadata and salt. validate() is called as a precondition
    // so collector can be assured metadata was not changed
    pub fun reveal(metadata: AnyStruct{GaiaMetadata}, salt: [UInt8]) {
      pre {
        self.mintID != nil
          : ""Template has not yet been minted.""
        !self.revealed()
          : ""NFT Template has already been revealed""
        self.validate(metadata: metadata, salt: salt)
          : ""salt || metadata.hash() does not hash to checksum""
      }
      self.metadata = metadata
      self._salt = salt
    }

    pub fun checksum(): [UInt8] {
      return self._checksum
    }

    pub fun salt(): [UInt8]? {
      return self._salt
    }

    // Check to see if metadata has been revealed
    pub fun revealed(): Bool {
      return self.metadata != nil
    }

    // Mark the NFT as minted
    pub fun markMinted(nftId: UInt64) {
      self.mintID = nftId
    }

    // Implements MetadataResolver.getViews
    pub fun getViews(): [Type] {
      if (!self.revealed()) {
        return [Type<MetadataViews.Display>()]
      }
      return self.metadata!.getViews()
    }

    // Implements MetadataResolver.resolveView
    pub fun resolveView(_ view: Type): AnyStruct? {
      if (!self.revealed()) {
        if (view != Type<MetadataViews.Display>()) {
          return nil
        }
        return self.defaultDisplay
      }
      return self.metadata!.resolveView(view)
    }

    init(checksum: [UInt8], defaultDisplay: MetadataViews.Display) {
      self._checksum = checksum
      self.defaultDisplay = defaultDisplay

      self._salt = nil
      self.metadata = nil
      self.mintID = nil
    }
  }

  // Public helper function to be able to inspect any Template
  pub fun getTemplate(setId: UInt64, templateId: UInt64): {TemplateNFT} {
    let setRef = &self.sets[setId] as &Set
    return setRef.templates[templateId]
  }

  // GaiaAccount
  //
  // It is expected that some accounts will be managing multiple Sets. Because
  // a SetManager gives authority over a single Set, GaiaAccount was created to 
  // allow an account to organize multiple SetManager resources. A GaiaAccount
  // can only store one SetManager per Set

  // Anyone is technically allowed to add SetManager resources to a GaiaAccount,
  // but only an Admin is allowed to create and assign SetManagers.
  pub resource interface GaiaAccountPublic {
    pub fun addSetManager(setManager: @SetManager)
    pub fun getSetManagersCount(): Int
  }

  pub resource GaiaAccount: GaiaAccountPublic {

    // SetId: SetManager
    access(self) let setManagers: @{UInt64: SetManager} 

    // Add a SetManager and index it by the setId. Panic if we already have
    // a SetManager for that setId.
    pub fun addSetManager(setManager: @SetManager) {
      pre {
        !self.setManagers.containsKey(setManager.setId)
          : ""Cannot add SetManager: SetManager already exists for this set.""
      }
      let setManagerId = setManager.id
      let setId = setManager.setId
      let oldSm <- self.setManagers.insert(key: setId, <- setManager)
      destroy oldSm
      emit SetManagerAssigned(
        setManagerId: setManagerId,
        setId: setId,
        account: self.owner?.address
      )
    }

    // Get number of SetManagers in account
    pub fun getSetManagersCount(): Int {
      return self.setManagers.length
    }

    // Borrow the SetManager for the specified Set if it exists.
    pub fun borrowSetManager(setId: UInt64): &SetManager {
      pre {
        self.setManagers.containsKey(setId)
          : ""GaiaAccount does not contain a SetManager for the provided setId.""
      }
      let setManagerRef = &self.setManagers[setId] as &GaiaNFT.SetManager
      return setManagerRef
    }
    
    // We do not want to allow anyone to overwrite SetManagers using the
    // public addSetManager function. Therefore, a SetManager will
    // have to be removed before it can be replaced with a modified
    // SetManager token (if desired by the GaiaAccount owner)
    pub fun removeSetManager(setId: UInt64) {
      pre {
        self.setManagers.containsKey(setId)
          : ""Cannot remove SetManager: SetManager does not exist for this set.""
      }
      let setManager <- self.setManagers.remove(key: setId)!
      emit SetManagerRemoved(
        setManagerId: setManager.id,
        setId: setId,
        account: self.owner?.address
      )
      destroy setManager
    }

    init() {
      self.setManagers <- {}
    }

    destroy() {
      destroy self.setManagers
    }
  }

  // Exposed function to create a GaiaAccount
  pub fun createGaiaAccount(): @GaiaAccount {
    return <-create GaiaAccount()
  }

  // Predefined Set Manager Roles
  pub enum SetManagerRole: UInt8 {

    // Create templates, NFTs, and new Set Managers.
    pub case Super     

    // Create templates, NFTs.
    pub case Operator  
  }

  // Set Managers 
  // Create Templates and mint NFTs from them
  //
  pub resource SetManager {
    pub let id: UInt64
    pub let setId: UInt64
    pub let role: SetManagerRole

    // Get reference to the Set made accessible to this SetManager
    pub fun getSet(): &Set {
      pre {
        !self.revoked(): ""SetManager Token has been revoked.""
      }
      return &GaiaNFT.sets[self.setId] as &Set
    }

    // Super SetManagers can create new SetManagers
    pub fun createSetManager(role: SetManagerRole): @SetManager {
      pre {
        !self.revoked(): ""SetManager Token has been revoked.""
        self.role == SetManagerRole.Super
          : ""Cannot create new Set Manager: Needs Super privileges""
      }
      return <- create SetManager(setId: self.setId, role: role)
    }

    // Helper function to test if SetManager token has been revoked by Admin
    pub fun revoked(): Bool {
        return GaiaNFT.setManagerRevocations.containsKey(self.id)
    }

    init(
      setId: UInt64, 
      role: SetManagerRole
    ){
      self.id = GaiaNFT.setManagerSupply
      GaiaNFT.setManagerSupply = GaiaNFT.setManagerSupply + 1
      self.setId = setId
      self.role = role
      emit SetManagerCreated(
        setManagerId: self.id,
        setId: self.setId,
        role: self.role.rawValue
      )
    }
  }

  // Admin
  //
  // The Admin is meant to be a singleton superuser of the contract. The Admin
  // is responsible for creating Sets and SetManagers for managing the sets.
  pub resource Admin {

    // Create a set with the provided SetMetadata.
    pub fun createSet(metadata: SetMetadata) {
      GaiaNFT.createSet(metadata: metadata)
    }

    // Create a SetManager for any preexisting Set
    pub fun createSetManager(setId: UInt64, role: SetManagerRole): @SetManager {
      pre {
        GaiaNFT.sets[setId] != nil
          : ""Cannot create Set Manager: Set doesn't exist""
      }
      return <- create SetManager(setId: setId, role: role)
    }

    // Revoke a SetManager's Set modification privileges.
    pub fun revokeSetManager(setManagerId: UInt64) {
      pre {
        setManagerId < GaiaNFT.setManagerSupply
          : ""Provided setManagerId does not exist.""
      }
      GaiaNFT.setManagerRevocations[setManagerId] = true
      emit SetManagerRevoked(
        setManagerId: setManagerId
      )
    }

    // Unrevoke a SetManager's Set modification privileges.
    pub fun unrevokeSetManager(setManagerId: UInt64) {
      pre {
        GaiaNFT.setManagerRevocations.containsKey(setManagerId)
          : ""SetManager privilege is not currently revoked.""
      }
      GaiaNFT.setManagerRevocations.remove(key: setManagerId)
      emit SetManagerUnrevoked(
        setManagerId: setManagerId
      )
    }
  }

  // Contract constructor
  init() {

    // Collection Paths
    self.CollectionStoragePath = /storage/GaiaCollection
    self.CollectionPublicPath = /public/GaiaCollection
    self.CollectionPrivatePath = /private/GaiaCollection

    // GaiaAccount Paths
    self.GaiaAccountPublicPath = /public/GaiaAccountPublic
    self.GaiaAccountPath = /storage/GaiaAccount

    // Admin Storage Path. Save the singleton Admin resource to contract
    // storage.
    self.AdminStoragePath = /storage/GaiaAdmin
    self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)
    
    // Initializations
    self.totalSupply = 0
    self.sets <- {}
    self.setManagerSupply = 0
    self.setManagerRevocations = {}

    emit ContractInitialized()
  }
}"
A.0000000000000000.GaiaOrder,"import GaiaFee from 0x8b148183c28ff88f
import FungibleToken from 0xf233dcee88fe0abe
import NFTStorefront from 0x4eb8a10cb9f87357
import NonFungibleToken from 0x1d7e57aa55817448

pub contract GaiaOrder {

    pub let BUYER_FEE: String
    pub let SELLER_FEE: String
    pub let OTHER: String
    pub let ROYALTY: String
    pub let REWARD: String

    init() {
        // market buyer fee (on top of the price)
        self.BUYER_FEE = ""BUYER_FEE""

        // market seller fee
        self.SELLER_FEE = ""SELLER_FEE""

        // additional payments
        self.OTHER = ""OTHER""

        // royalty
        self.ROYALTY = ""ROYALTY""

        // seller reward
        self.REWARD = ""REWARD""
    }

    // PaymentPart
    // 
    pub struct PaymentPart {
        // receiver address
        pub let address: Address

        // payment rate
        pub let rate: UFix64

        init(address: Address, rate: UFix64) {
            self.address = address
            self.rate = rate
        }
    }

    // Payment
    // Describes payment in the event OrderAvailable
    // 
    pub struct Payment {
        // type of payment
        pub let type: String

        // receiver address
        pub let address: Address

        // payment rate
        pub let rate: UFix64

        // payment amount
        pub let amount: UFix64

        init(type: String, address: Address, rate: UFix64, amount: UFix64) {
            self.type = type
            self.address = address
            self.rate = rate
            self.amount = amount
        }
    }

    // OrderAvailable
    // Order created and available for purchase
    // 
    pub event OrderAvailable(
        orderAddress: Address,
        orderId: UInt64,
        nftType: String,
        nftId: UInt64,
        vaultType: String,
        price: UFix64,
        payments: [Payment]
    )

    pub event OrderClosed(
        orderAddress: Address,
        orderId: UInt64,
        nftType: String,
        nftId: UInt64,
        vaultType: String,
        price: UFix64,
        buyerAddress: Address,
        cuts: [PaymentPart]
    )

    pub event OrderCancelled(
        orderAddress: Address,
        orderId: UInt64,
        nftType: String,
        nftId: UInt64,
        vaultType: String,
        price: UFix64,
        cuts: [PaymentPart]
    )

    // addOrder
    // Wrapper for NFTStorefront.createListing
    //
    pub fun addOrder(
        storefront: &NFTStorefront.Storefront,
        nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>,
        nftType: Type,
        nftId: UInt64,
        vaultPath: PublicPath,
        vaultType: Type,
        price: UFix64,
        extraCuts: [PaymentPart],
        royalties: [PaymentPart]
    ): UInt64 {
        let orderAddress = storefront.owner!.address
        let payments: [Payment] = []
        let saleCuts: [NFTStorefront.SaleCut] = []
        var percentage = 1.0

        let addPayment = fun (type: String, address: Address, rate: UFix64) {
            assert(rate >= 0.0 && rate < 1.0, message: ""Rate must be in range [0..1)"")
            let amount = price * rate
            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(vaultPath)
            assert(receiver.borrow() != nil, message: ""Missing or mis-typed fungible token receiver"")

            payments.append(Payment(type:type, address:address, rate: rate, amount: amount))
            saleCuts.append(NFTStorefront.SaleCut(receiver: receiver, amount: amount))

            percentage = percentage - rate
        }

        if GaiaFee.buyerFee > 0.0 {
            addPayment(GaiaOrder.BUYER_FEE, GaiaFee.feeAddress(), GaiaFee.buyerFee)
        }
        if GaiaFee.sellerFee > 0.0 {
            addPayment(GaiaOrder.SELLER_FEE, GaiaFee.feeAddress(), GaiaFee.sellerFee)
        }

        for cut in extraCuts {
            addPayment(GaiaOrder.OTHER, cut.address, cut.rate)
        }

        for royalty in royalties {
            addPayment(GaiaOrder.ROYALTY, royalty.address, royalty.rate)
        }

        addPayment(GaiaOrder.REWARD, orderAddress, percentage)

        let orderId = storefront.createListing(
            nftProviderCapability: nftProvider,
            nftType: nftType,
            nftID: nftId,
            salePaymentVaultType: vaultType,
            saleCuts: saleCuts
        )

        emit OrderAvailable(
            orderAddress: orderAddress,
            orderId: orderId,
            nftType: nftType.identifier,
            nftId: nftId,
            vaultType: vaultType.identifier,
            price: price,
            payments: payments
        )

        return orderId
    }

    // closeOrder
    // Purchase nft by o
    //
    pub fun closeOrder(
        storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic},
        orderId: UInt64,
        orderAddress: Address,
        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},
        paymentVault: @FungibleToken.Vault,
        buyerAddress: Address
    ): @NonFungibleToken.NFT {
        let details = listing.getDetails()
        let cuts: [PaymentPart] = []
        for saleCut in details.saleCuts {
            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))
        }

        emit OrderClosed(
            orderAddress: orderAddress,
            orderId: orderId,
            nftType: details.nftType.identifier,
            nftId: details.nftID,
            vaultType: details.salePaymentVaultType.identifier,
            price: details.salePrice,
            buyerAddress: buyerAddress,
            cuts: cuts
        )

        let item <- listing.purchase(payment: <-paymentVault)
        storefront.cleanup(listingResourceID: orderId)
        return <- item
    }

    // removeOrder
    // Cancel sale, dismiss order
    //
    pub fun removeOrder(
        storefront: &NFTStorefront.Storefront,
        orderId: UInt64,
        orderAddress: Address,
        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},
    ) {
        let details = listing.getDetails()
        let cuts: [PaymentPart] = []
        for saleCut in details.saleCuts {
            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))
        }

        emit OrderCancelled(
            orderAddress: orderAddress,
            orderId: orderId,
            nftType: details.nftType.identifier,
            nftId: details.nftID,
            vaultType: details.salePaymentVaultType.identifier,
            price: details.salePrice,
            cuts: cuts
        )

        storefront.removeListing(listingResourceID: orderId)
    }
}
"
A.0000000000000000.GaiaPrimarySale,"/**
    GaiaPrimarySale.cdc

    Description: Facilitates the exchange of Fungible Tokens for NFTs.
**/

import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe

pub contract GaiaPrimarySale {

    pub let PrimarySaleStoragePath: StoragePath
    pub let PrimarySalePublicPath: PublicPath
    pub let PrimarySalePrivatePath: PrivatePath

    pub event PrimarySaleCreated(
        externalID: String,
        name: String,
        description: String,
        imageURI: String,
        nftType: Type,
        prices: {String: UFix64}
    )
    pub event PrimarySaleStatusChanged(externalID: String, status: String)
    pub event PriceSet(externalID: String, type: String, price: UFix64)
    pub event PriceRemoved(externalID: String, type: String)
    pub event AssetAdded(externalID: String, assetID: UInt64)
    pub event NFTPurchased(externalID: String, nftType: Type, assetID: UInt64, nftID: UInt64, purchaserAddress: Address, priceType: String, price: UFix64)
    pub event ContractInitialized()

    access(contract) let primarySaleIDs: [String]

    pub resource interface IMinter {
        pub fun mint(assetID: UInt64, creator: Address): @NonFungibleToken.NFT
    }

    // Data struct signed by account with specified ""adminPublicKey.""
    //
    // Permits accounts to purchase specific NFTs for some period of time.
    pub struct AdminSignedData {
        pub let externalID: String
        pub let priceType: String
        pub let primarySaleAddress: Address
        pub let purchaserAddress: Address
        pub let assetIDs: [UInt64]
        pub let expiration: UInt64 // unix timestamp

        init(externalID: String, primarySaleAddress: Address, purchaserAddress: Address, assetIDs: [UInt64], priceType: String, expiration: UInt64){
            self.externalID = externalID
            self.primarySaleAddress = primarySaleAddress
            self.purchaserAddress = purchaserAddress
            self.assetIDs = assetIDs
            self.priceType = priceType
            self.expiration = expiration
        }

        pub fun toString(): String {
            var assetIDs = """"
            var i = 0
            while (i < self.assetIDs.length) {
                if (i > 0) {
                    assetIDs = assetIDs.concat("","")
                }
                assetIDs = assetIDs.concat(self.assetIDs[i].toString())
                i = i + 1
            }
            return self.externalID.concat("":"")
                .concat(self.primarySaleAddress.toString()).concat("":"")
                .concat(self.purchaserAddress.toString()).concat("":"")
                .concat(assetIDs).concat("":"")
                .concat(self.priceType).concat("":"")
                .concat(self.expiration.toString())
        }
    }

    pub enum PrimarySaleStatus: UInt8 {
        pub case PAUSED
        pub case OPEN
        pub case CLOSED
    }

    pub resource interface PrimarySalePublic {
        pub fun getDetails(): PrimarySaleDetails
        pub fun getSupply(): Int
        pub fun getPrices(): {String: UFix64}
        pub fun getStatus(): String
        pub fun purchaseNFTs(
            payment: @FungibleToken.Vault,
            data: AdminSignedData,
            sig: String
        ): @[NonFungibleToken.NFT]
    }

    pub resource interface PrimarySalePrivate {
        pub fun pause()
        pub fun open()
        pub fun close()
        pub fun setDetails(
            name: String,
            description: String,
            imageURI: String
        )
        pub fun setPrice(priceType: String, price: UFix64)
        pub fun setAdminPublicKey(adminPublicKey: String)
        pub fun addAsset(assetID: UInt64)
    }

    pub struct PrimarySaleDetails {
        pub var name: String
        pub var description: String
        pub var imageURI: String

        init(
            name: String,
            description: String,
            imageURI: String
        ) {
            self.name = name
            self.description = description
            self.imageURI = imageURI
        }
    }

    pub resource PrimarySale: PrimarySalePublic, PrimarySalePrivate {
        access(self) var externalID: String
        pub let nftType: Type
        access(self) var status: PrimarySaleStatus
        access(self) var prices: {String: UFix64}
        access(self) var availableAssetIDs: {UInt64: Bool}

        // primary sale metadata
        access(self) var details: PrimarySaleDetails

        access(self) let minterCap: Capability<&{IMinter}>
        access(self) let paymentReceiverCap: Capability<&{FungibleToken.Receiver}>

        // pub key used to verify signatures from a specified admin
        access(self) var adminPublicKey: String

        init(
            externalID: String,
            name: String,
            description: String,
            imageURI: String,
            nftType: Type,
            prices: {String: UFix64},
            minterCap: Capability<&{IMinter}>,
            paymentReceiverCap: Capability<&{FungibleToken.Receiver}>,
            adminPublicKey: String
        ) {
            self.externalID = externalID
            self.details = PrimarySaleDetails(
                name: name,
                description: description,
                imageURI: imageURI
            )
            self.nftType = nftType
            self.status = PrimarySaleStatus.PAUSED // primary sale is paused initially
            self.availableAssetIDs = {} // no asset IDs assigned to primary sale initially
            self.prices = prices

            self.minterCap = minterCap
            self.paymentReceiverCap = paymentReceiverCap

            self.adminPublicKey = adminPublicKey

            emit PrimarySaleCreated(
                externalID: externalID,
                name: name,
                description: description,
                imageURI: imageURI,
                nftType: nftType,
                prices: prices
            )
        }

        pub fun getStatus(): String {
            if (self.status == PrimarySaleStatus.PAUSED) {
                return ""PAUSED""
            } else if (self.status == PrimarySaleStatus.OPEN) {
                return ""OPEN""
            } else if (self.status == PrimarySaleStatus.CLOSED) {
                return ""CLOSED""
            } else {
                return """"
            }
        }

        pub fun setDetails(
            name: String,
            description: String,
            imageURI: String
        ) {
            self.details = PrimarySaleDetails(
                name: name,
                description: description,
                imageURI: imageURI
            )
        }

        pub fun getDetails(): PrimarySaleDetails {
            return self.details
        }

        pub fun setPrice(priceType: String, price: UFix64) {
            self.prices[priceType] = price
            emit PriceSet(externalID: self.externalID, type: priceType, price: price)
        }

        pub fun removePrice(priceType: String) {
            self.prices.remove(key: priceType)
            emit PriceRemoved(externalID: self.externalID, type: priceType)
        }

        pub fun getPrices(): {String: UFix64} {
            return self.prices
        }

        pub fun getSupply(): Int {
            return self.availableAssetIDs.length
        }

        pub fun setAdminPublicKey(adminPublicKey: String) {
            self.adminPublicKey = adminPublicKey
        }

        pub fun addAsset(assetID: UInt64) {
            self.availableAssetIDs[assetID] = true
            emit AssetAdded(externalID: self.externalID, assetID: assetID)
        }

        pub fun pause() {
            self.status = PrimarySaleStatus.PAUSED
            emit PrimarySaleStatusChanged(externalID: self.externalID, status: self.getStatus())
        }

        pub fun open() {
            pre {
                self.status != PrimarySaleStatus.OPEN : ""Primary sale is already open""
                self.status != PrimarySaleStatus.CLOSED : ""Cannot resume primary sale that is closed""
            }

            self.status = PrimarySaleStatus.OPEN
            emit PrimarySaleStatusChanged(externalID: self.externalID, status: self.getStatus())
        }

        pub fun close() {
            self.status = PrimarySaleStatus.CLOSED
            emit PrimarySaleStatusChanged(externalID: self.externalID, status: self.getStatus())
        }

        access(self) fun verifyAdminSignedData(data: AdminSignedData, sig: String): Bool {
            let publicKey = PublicKey(
                publicKey: self.adminPublicKey.decodeHex(),
                signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
            )

            return publicKey.verify(
                signature: sig.decodeHex(),
                signedData: data.toString().utf8,
                domainSeparationTag: ""FLOW-V0.0-user"",
                hashAlgorithm: HashAlgorithm.SHA3_256
            )
        }

        pub fun purchaseNFTs(
            payment: @FungibleToken.Vault,
            data: AdminSignedData,
            sig: String
        ): @[NonFungibleToken.NFT] {
            pre {
                self.externalID == data.externalID: ""externalID mismatch""
                self.status == PrimarySaleStatus.OPEN: ""primary sale is not open""
                data.assetIDs.length > 0: ""must purchase at least one NFT""
                self.verifyAdminSignedData(data: data, sig: sig): ""invalid admin signature for data""
                data.expiration >= UInt64(getCurrentBlock().timestamp): ""expired signature""
            }

            let price = self.prices[data.priceType] ?? panic(""Invalid price type"")

            assert(payment.balance == price * UFix64(data.assetIDs.length), message: ""payment vault does not contain requested price"")

            let receiver = self.paymentReceiverCap.borrow()!
            receiver.deposit(from: <- payment)

            let minter = self.minterCap.borrow() ?? panic(""cannot borrow minter"")

            var i: Int = 0
            let nfts: @[NonFungibleToken.NFT] <- []
            while i < data.assetIDs.length {
                let assetID = data.assetIDs[i]
                assert(self.availableAssetIDs.containsKey(assetID), message: ""NFT is not available for purchase: "".concat(assetID.toString()))
                self.availableAssetIDs.remove(key: assetID)
                let nft <- minter.mint(assetID: assetID, creator: data.purchaserAddress)
                emit NFTPurchased(externalID: self.externalID, nftType: nft.getType(), assetID: assetID, nftID: nft.id, purchaserAddress: data.purchaserAddress, priceType: data.priceType, price: price)
                nfts.append(<-nft)
                i = i + 1
            }
            assert(nfts.length == data.assetIDs.length, message: ""nft count mismatch"")

            return <- nfts
        }
    }

    pub fun createPrimarySale(
        externalID: String,
        name: String,
        description: String,
        imageURI: String,
        nftType: Type,
        prices: {String: UFix64},
        minterCap: Capability<&{IMinter}>,
        paymentReceiverCap: Capability<&{FungibleToken.Receiver}>,
        adminPublicKey: String
    ): @PrimarySale {
        assert(!self.primarySaleIDs.contains(externalID), message: ""Primary sale external ID is already in use"")

        self.primarySaleIDs.append(externalID)

        return <- create PrimarySale(
            externalID: externalID,
            name: name,
            description: description,
            imageURI: imageURI,
            nftType: nftType,
            prices: prices,
            minterCap: minterCap,
            paymentReceiverCap: paymentReceiverCap,
            adminPublicKey: adminPublicKey
        )
    }

    init() {
        // default paths but not intended for multiple primary sales on same acct
        self.PrimarySaleStoragePath = /storage/GaiaPrimarySale001
        self.PrimarySalePublicPath = /public/GaiaPrimarySale001
        self.PrimarySalePrivatePath = /private/GaiaPrimarySale001

        self.primarySaleIDs = []

        emit ContractInitialized()
    }
}
"
A.0000000000000000.Profile,"/**   Generic Profile Contract
***   ========================
***
***   I am trying to figure out a generic re-usable Profile Micro-Contract
***   that any application can consume and use. It should be easy to integrate
***   this contract with any application, and as a user moves from application
***   to application this profile can come with them. A core concept here is
***   given a Flow Address, a profiles details can be publically known. This
***   should mean that if an application were to use/store the Flow address of
***   a user, than this profile could be visible, and maintained with out storing
***   a copy in an applications own databases. I believe that anytime we can move
***   a common database table into a publically accessible contract/resource is a
***   win.
***
***   It could be a little more than that too. As Flow Accounts can now have
***   multiple contracts, it could be fun to allow for these accounts to have
***   some basic information too. https://flow-view-source.com is a side project
***   of mine (qvvg) and if you are looking at an account on there, or a contract
***   deployed to an account I will make it so it pulls info from a properly
***   configured Profile Resource.
***
***
***
***   Table of Contents
***   =================
***
***   L1  - Intro
***   L24 - Table of Contents
***   L41 - General Profile Contract Info
***   L54 - How Verification Works
***   L67 - Examples
***     L78  - Initializing a Profile Resource
***     L130 - Interacting with Profile Resource (as Owner)
***     L184 - As a Verified Account, Verifiy Another Account
***     L231 - Reading a Profile Given a Flow Address
***     L265 - Reading a Multiple Profiles Given Multiple Flow Addresses
***     L299 - Checking if Flow Account is Initialized
***
***
***
***   General Profile Contract Info
***   =============================
***
***   Currently a profile consists of a couple main pieces:
***   - name b  An alias the profile owner would like to be refered as.
***   - avatar - An href the profile owner would like applications to use to represent them graphically.
***   - color - A valid html color (not verified in any way) applications can use to accent and personalize the experience.
***   - info - A short description about the account.
***   - verified - A boolean value showing if the account has been verified by another verified account.
***
***
***
***
***   How verification works.
***   =======================
***
***   A profile being verified means two things:
***   - It has been verified by another verified account.
***   - It can no longer updated its name.
***
***   If I am being honest, it's mostly an experiment. I sort of want to see what
***   happens with it. Reach out to me (qvvg) on discord if you want to be verified.
***
***
***
***
***   Examples
***   ========
***
***   The following examples will include both raw cadence transactions and scripts
***   as well as how you can call them from FCL. The FCL examples are currently assuming
***   the following configuration is called somewhere in your application before the
***   the actual calls to the chain are invoked.
***
***
***
***
***   Initializing a Profile Resource
***   ===============================
***
***   Initializing should be done using the paths that the contract exposes.
***   This will lead to predictability in how applications can look up the data.
***
---Cadence Tx---

import Profile from 0xba1132bc08f82fe2

transaction {
  let address: address
  prepare(acct: AuthAccount) {
    self.address = acct.address
    if !Profile.check(self.address) {
      acct.save(<- Profile.new(), to: Profile.privatePath)
      acct.link<&Profile.Base{Profile.Public}>(Profile.publicPath, target: Profile.privatePath)
    }
  }
  post {
    Profile.check(self.address): ""Account was not initialized""
  }
}

---FCL JS-SDK---

import * as fcl from ""@onflow/fcl""

await fcl.send([
  fcl.proposer(fcl.authz),
  fcl.payer(fcl.authz),
  fcl.authorizations([
    fcl.authz,
  ]),
  fcl.limit(35),
  fcl.transaction`
    import Profile from 0xba1132bc08f82fe2
    
    transaction {
      prepare(acct: AuthAccount) {
        acct.save(<- Profile.new(), to: Profile.privatePath)
        acct.link<&Profile.Base{Profile.Public}>(Profile.publicPath, target: Profile.privatePath)
      }
    }
  `
]).then(fcl.decode)

----------------
***
***
***
***
***   Interacting with Profile Resource (as Owner)
***   ============================================
***
***   As the owner of a resource you can update the following:
***   - name using `.setName(""MyNewName"")` (as long as you arent verified)
***   - avatar using `.setAvatar(""https://url.to.my.avatar"")`
***   - color using `.setColor(""tomato"")`
***   - info using `.setInfo(""I like to make things with Flow :wave:"")`
***
---Cadence Tx---

import Profile from 0xba1132bc08f82fe2

transaction(name: String) {
  prepare(account: AuthAccount) {
    account
      .borrow<&{Profile.Owner}>(from: Profile.privatePath)!
      .setName(name)
  }
}

---FCL JS-SDK---

import * as fcl from ""@onflow/fcl""
import * as t from ""@onflow/types""

await fcl.send([
  fcl.proposer(fcl.authz),
  fcl.payer(fcl.authz),
  fcl.authorizations([
    fcl.authz,
  ]),
  fcl.limit(35),
  fcl.args([
    fcl.arg(""qvvg"", t.String), // name
  ]),
  fcl.transaction`
    import Profile from 0xba1132bc08f82fe2
    
    transaction(name: String) {
      prepare(account: AuthAccount) {
        account
          .borrow<&{Profile.Owner}>(from: Profile.privatePath)!
          .setName(name)
      }
    }
  `
]).then(fcl.decode)

----------------
***
***
***
***
***   As a Verified Account, Verifiy Another Account
***   ==============================================
***
---Cadence Tx---

import Profile from 0xba1132bc08f82fe2

transaction(accountToBeVerified: Address) {
  prepare(accountDoingTheVerification: AuthAccount) {
    accountDoingTheVerification
      .borrow<&{Profile.Owner}>(from: Profile.privatePath)!
      .grantVerifiedStatus(accountToBeVerified)
  }
} 
---FCL JS-SDK---

import * as fcl from ""@onflow/fcl""
import * as t from ""@onflow/types""

await fcl.send([
  fcl.proposer(fcl.authz),
  fcl.payer(fcl.authz),
  fcl.authorizations([
    fcl.authz,
  ]),
  fcl.limit(35),
  fcl.args([
    fcl.arg(""0xf117a8efa34ffd58"", t.Address),
  ]),
  fcl.transaction`
    import Profile from 0xba1132bc08f82fe2
    
    transaction(accountToBeVerified: Address) {
      prepare(accountDoingTheVerification: AuthAccount) {
        accountDoingTheVerification
          .borrow<&{Profile.Owner}>(from: Profile.privatePath)!
          .grantVerifiedStatus(accountToBeVerified)
      }
    } 
  `
]).then(fcl.decode)

----------------
***
***
***
***
***   Reading a Profile Given a Flow Address
***   ======================================
***
---Cadence Sc---

import Profile from 0xba1132bc08f82fe2

pub fun main(address: Address): Profile.ReadOnly? {
  return Profile.read(address)
}

---FCL JS-SDK---

import * as fcl from ""@onflow/fcl""
import * as t from ""@onflow/types""

await fcl.send([
  fcl.args([
    fcl.arg(""0xba1132bc08f82fe2"", t.Address),
  ]),
  fcl.script`
    import Profile from 0xba1132bc08f82fe2
    
    pub fun main(address: Address): Profile.ReadOnly? {
      return Profile.read(address)
    }
  `
]).then(fcl.decode)

----------------
***
***
***
***
***   Reading a Multiple Profiles Given Multiple Flow Addresses
***   =========================================================
***
---Cadence Sc---

import Profile from 0xba1132bc08f82fe2

pub fun main(addresses: [Address]): {Address: Profile.ReadOnly} {
  return Profile.readMultiple(addresses)
}

---FCL JS-SDK---

import * as fcl from ""@onflow/fcl""
import * as t from ""@onflow/types""

await fcl.send([
  fcl.args([
    fcl.arg([""0xba1132bc08f82fe2"", ""0xf76a4c54f0f75ce4"", ""0xf117a8efa34ffd58""], t.Array(t.Address)),
  ]),
  fcl.script`
    import Profile from 0xba1132bc08f82fe2
    
    pub fun main(addresses: [Address]): {Address: Profile.ReadOnly} {
      return Profile.readMultiple(addresses)
    }
  `
]).then(fcl.decode)

----------------
***
***
***
***
***   Checking if Flow Account is Initialized
***   =======================================
***
---Cadence Sc---

import Profile from 0xba1132bc08f82fe2

pub fun main(address: Address): Bool {
  return Profile.check(address)
}

---FCL JS-SDK---

import * as fcl from ""@onflow/fcl""
import * as t from ""@onflow/types""

await fcl.send([
  fcl.args([
    fcl.arg(""0xba1132bc08f82fe2"", t.Address),
  ]),
  fcl.script`
    import Profile from 0xba1132bc08f82fe2
    
    pub fun main(address: Address): Bool {
      return Profile.check(address)
    }
  `
]).then(fcl.decode)

----------------
**/
pub contract Profile {
  pub let publicPath: PublicPath
  pub let privatePath: StoragePath

  pub resource interface Public {
    pub fun getName(): String
    pub fun getAvatar(): String
    pub fun getColor(): String
    pub fun getInfo(): String
    pub fun getVerified(): Bool
    pub fun asReadOnly(): Profile.ReadOnly
    
    access(contract) fun internal_setVerifiedStatus(_ val: Bool)
  }
  
  pub resource interface Owner {
    pub fun getName(): String
    pub fun getAvatar(): String
    pub fun getColor(): String
    pub fun getInfo(): String
    pub fun getVerified(): Bool
    
    pub fun setName(_ name: String) {
      pre {
        !self.getVerified():
          ""Verified Profiles can't change their name.""
        name.length <= 15:
          ""Names must be under 15 characters long.""
      }
    }
    pub fun setAvatar(_ src: String)
    pub fun setColor(_ color: String)
    pub fun setInfo(_ info: String) {
      pre {
        info.length <= 280:
          ""Profile Info can at max be 280 characters long.""
      }
    }
    
    pub fun grantVerifiedStatus(_ address: Address) {
      pre {
        self.getVerified():
          ""Only Verified Profiles can Verify another Profile.""
      }
    }
    
    pub fun revokeVerifiedStatus(_ address: Address) {
      pre {
        self.getVerified():
          ""Only Verified Profiles can revoke a Verification from another Profile.""
      }
    }
  }
  
  pub resource Base: Owner, Public {
    access(self) var name: String
    access(self) var avatar: String
    access(self) var color: String
    access(self) var info: String
    access(self) var verified: Bool
    
    init() {
      self.name = ""Anon""
      self.avatar = """"
      self.color = ""#232323""
      self.info = """"
      self.verified = false
    }
    
    pub fun getName(): String { return self.name }
    pub fun getAvatar(): String { return self.avatar }
    pub fun getColor(): String {return self.color }
    pub fun getInfo(): String { return self.info }
    pub fun getVerified(): Bool { return self.verified }
    
    pub fun setName(_ name: String) { self.name = name }
    pub fun setAvatar(_ src: String) { self.avatar = src }
    pub fun setColor(_ color: String) { self.color = color }
    pub fun setInfo(_ info: String) { self.info = info }
    
    access(contract) fun internal_setVerifiedStatus(_ val: Bool) { self.verified = val }
  
    pub fun grantVerifiedStatus(_ address: Address) {
      Profile.fetch(address).internal_setVerifiedStatus(true)
    }
    
    pub fun revokeVerifiedStatus(_ address: Address) {
      Profile.fetch(address).internal_setVerifiedStatus(false)
    }
    
    pub fun asReadOnly(): Profile.ReadOnly {
      return Profile.ReadOnly(
        address: self.owner?.address,
        name: self.getName(),
        avatar: self.getAvatar(),
        color: self.getColor(),
        info: self.getInfo(),
        verified: self.getVerified()
      )
    }
  }

  pub struct ReadOnly {
    pub let address: Address?
    pub let name: String
    pub let avatar: String
    pub let color: String
    pub let info: String
    pub let verified: Bool
    
    init(address: Address?, name: String, avatar: String, color: String, info: String, verified: Bool) {
      self.address = address
      self.name = name
      self.avatar = avatar
      self.color = color
      self.info = info
      self.verified = verified
    }
  }
  
  pub fun new(): @Profile.Base {
    return <- create Base()
  }
  
  pub fun check(_ address: Address): Bool {
    return getAccount(address)
      .getCapability<&{Profile.Public}>(Profile.publicPath)
      .check()
  }
  
  pub fun fetch(_ address: Address): &{Profile.Public} {
    return getAccount(address)
      .getCapability<&{Profile.Public}>(Profile.publicPath)
      .borrow()!
  }
  
  pub fun read(_ address: Address): Profile.ReadOnly? {
    if let profile = getAccount(address).getCapability<&{Profile.Public}>(Profile.publicPath).borrow() {
      return profile.asReadOnly()
    } else {
      return nil
    }
  }
  
  pub fun readMultiple(_ addresses: [Address]): {Address: Profile.ReadOnly} {
    let profiles: {Address: Profile.ReadOnly} = {}
    for address in addresses {
      let profile = Profile.read(address)
      if profile != nil {
        profiles[address] = profile!
      }
    }
    return profiles
  }

    
  init() {
    self.publicPath = /public/profile
    self.privatePath = /storage/profile
    
    self.account.save(<- self.new(), to: self.privatePath)
    self.account.link<&Base{Public}>(self.publicPath, target: self.privatePath)
    
    self.account
      .borrow<&Base{Owner}>(from: self.privatePath)!
      .setName(""qvvg"")

    self.account
      .getCapability<&{Profile.Public}>(Profile.publicPath)
      .borrow()!
      .internal_setVerifiedStatus(true)
  }
}"
A.0000000000000000.SNKRHUDNFT,"// SPDX-License-Identifier: UNLICENSED

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import Crypto

pub contract SNKRHUDNFT: NonFungibleToken {

  // Events
  //
  // This contract is initialized
  pub event ContractInitialized()

  // NFT is minted
  pub event NFTMinted(
    nftID: UInt64,
    setID: UInt64,
    templateID: UInt64,
    displayName: String,
    displayDescription: String,
    displayURI: String,
    creator: Address,
  )

  // NFT is withdrawn from a collection
  pub event Withdraw(id: UInt64, from: Address?)

  // NFT is deposited from a collection
  pub event Deposit(id: UInt64, to: Address?)

  // NFT is destroyed
  pub event NFTDestroyed(id: UInt64)

  // NFT template metadata is revealed
  pub event NFTRevealed(
    nftID: UInt64,
    setID: UInt64,
    templateID: UInt64,
    displayName: String,
    displayDescription: String,
    displayURI: String,
    metadata: {String: String},
  )

  // Set has been created
  pub event SetCreated(setID: UInt64, metadata: SetMetadata)

  // Template has been added
  pub event TemplateAdded(setID: UInt64, templateID: UInt64, displayName: String, displayDescription: String, displayURI: String)

  // Set has been marked Locked
  pub event SetLocked(setID: UInt64, numTemplates: UInt64)

  // Paths
  //
  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath
  pub let CollectionPrivatePath: PrivatePath
  pub let AdminStoragePath: StoragePath

  // Total NFT supply
  pub var totalSupply: UInt64

  // Total number of sets
  access(self) var totalSets: UInt64

  // Dictionary mapping from set IDs to Set resources
  access(self) var sets: @{UInt64: Set}

  // Template metadata can have custom definitions but must have the
  // following implemented in order to power all the features of the
  // NFT contract.
  pub struct interface TemplateMetadata {

    // Hash representation of implementing structs.
    pub fun hash(): [UInt8]

    // Representative Display
    pub fun display(): MetadataViews.Display

    // Representative {string: string} serialization
    pub fun repr(): {String: String}

    // MetadataViews compliant
    pub fun getViews(): [Type]
    pub fun resolveView(_ view: Type): AnyStruct?
  }

  pub struct DynamicTemplateMetadata: TemplateMetadata {
    access(self) let _display: MetadataViews.Display
    access(self) let _metadata: {String: String}

    pub fun hash(): [UInt8] {
      return []
    }

    pub fun display(): MetadataViews.Display {
      return self._display
    }

    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.Display>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<MetadataViews.Display>():
          return self.display()
      }
      return nil
    }

    pub fun repr(): {String: String} {
      return self.metadata()
    }

    pub fun metadata(): {String: String} {
      return self._metadata
    }

    init(display: MetadataViews.Display, metadata: {String: String}) {
      self._display = display
      self._metadata = metadata
    }
  }

  // NFT
  //
  // ""Standard"" NFTs that implement MetadataViews and point
  // to a Template struct that give information about the NFTs metadata
  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

    // id is unique among all SNKRHUDNFT NFTs on Flow, ordered sequentially from 0
    pub let id: UInt64

    // setID and templateID help us locate the specific template in the
    // specific set which stores this NFTs metadata
    pub let setID: UInt64
    pub let templateID: UInt64

    // The creator of the NFT
    pub let creator: Address

    // Fetch the metadata Template represented by this NFT
    pub fun template(): {NFTTemplate} {
      return SNKRHUDNFT.getTemplate(setID: self.setID, templateID: self.templateID)
    }

    // Proxy for MetadataViews.Resolver.getViews implemented by Template
    pub fun getViews(): [Type] {
      let template = self.template()
      return template.getViews()
    }

    // Proxy for MetadataViews.Resolver.resolveView implemented by Template
    pub fun resolveView(_ view: Type): AnyStruct? {
      let template = self.template()
      return template.resolveView(view)
    }

    // NFT needs to be told which Template it follows
    init(setID: UInt64, templateID: UInt64, creator: Address) {
      self.id = SNKRHUDNFT.totalSupply
      SNKRHUDNFT.totalSupply = SNKRHUDNFT.totalSupply + 1
      self.setID = setID
      self.templateID = templateID
      self.creator = creator
      let defaultDisplay = self.template().defaultDisplay
      emit NFTMinted(
        nftID: self.id,
        setID: self.setID,
        templateID: self.templateID,
        displayName: defaultDisplay.name,
        displayDescription: defaultDisplay.description,
        displayURI: defaultDisplay.thumbnail.uri(),
        creator: self.creator
      )
    }

    // Emit NFTDestroyed when destroyed
    destroy() {
      emit NFTDestroyed(
        id: self.id,
      )
    }
  }

  // Collection
  //
  // Collections provide a way for collectors to store SNKRHUDNFT NFTs in their
  // Flow account.

  // Exposing this interface allows external parties to inspect a Flow
  // account's SNKRHUDNFT Collection and deposit NFTs
  pub resource interface CollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowSNKRHUDNFT(id: UInt64): &NFT
  }

  pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

    // NFTs are indexed by its globally assigned id
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    // Deposit a SNKRHUDNFT into the collection. Safe to assume id's are unique.
    pub fun deposit(token: @NonFungibleToken.NFT) {
      // Required to ensure this is a SNKRHUDNFT
      let token <- token as! @SNKRHUDNFT.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    // Withdraw an NFT from the collection.
    // Panics if NFT does not exist in the collection
    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs.containsKey(withdrawID)
          : ""NFT does not exist in collection.""
      }
      let token <- self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    // Return all the IDs from the collection.
    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    // Borrow a reference to the specified NFT
    // Panics if NFT does not exist in the collection
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs.containsKey(id)
          : ""NFT does not exist in collection.""
      }
      return &self.ownedNFTs[id] as &NonFungibleToken.NFT
    }

    // Borrow a reference to the specified NFT as a SNKRHUDNFT.
    // Panics if NFT does not exist in the collection
    pub fun borrowSNKRHUDNFT(id: UInt64): &NFT {
      pre {
        self.ownedNFTs.containsKey(id)
          : ""NFT does not exist in collection.""
      }
      let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
      return ref as! &NFT
    }

    // Return the MetadataViews.Resolver of the specified NFT
    // Panics if NFT does not exist in the collection
    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs.containsKey(id)
          : ""NFT does not exist in collection.""
      }
      let nft = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
      let typedNFT = nft as! &NFT
      return typedNFT
    }

    init() {
      self.ownedNFTs <- {}
    }

    // If the collection is destroyed, destroy the NFTs it holds, as well
    destroy() {
      destroy self.ownedNFTs
    }
  }

  // Anyone can make and store collections
  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  pub resource Set {

    // Globally assigned id based on number of created Sets.
    pub let id: UInt64

    pub var isLocked: Bool

    // Metadata for the Set
    pub var metadata: SetMetadata

    // Templates configured to be minted from this Set
    access(contract) var templates: [Template]

    // Number of NFTs that have minted from this Set
    pub var minted: UInt64

    // Add a new Template to the Set, only if the Set is Open
    pub fun addTemplate(template: Template) {
      pre {
        !self.isLocked : ""Set is locked. It cannot be modified""
      }
      let templateID = self.templates.length
      self.templates.append(template)

      let display = template.defaultDisplay
      emit TemplateAdded(setID: self.id, templateID: UInt64(templateID), displayName: display.name, displayDescription: display.description, displayURI: display.thumbnail.uri())
    }

    // Lock the Set if it is Open. This signals that this Set
    // will mint NFTs based only on the Templates configured in this Set.
    pub fun lock() {
      pre {
        !self.isLocked : ""Only an Open set can be locked.""
        self.templates.length > 0
          : ""Set must be configured with at least one Template.""
      }
      self.isLocked = true
      emit SetLocked(setID: self.id, numTemplates: UInt64(self.templates.length))
    }

    // Mint numToMint NFTs with the supplied creator attribute. The NFT will
    // be minted into the provided receiver
    pub fun mint(
      templateID: UInt64,
      creator: Address
    ): @NFT {
      pre {
        templateID < UInt64(self.templates.length)
          : ""templateID does not exist in Set.""
        self.templates[templateID].mintID == nil
          : ""Template has already been marked as minted.""
      }
      let nft <-create NFT(
          setID: self.id,
          templateID: templateID,
          creator: creator
        )
      self.templates[templateID].markMinted(nftID: nft.id)
      self.minted = self.minted + 1
      return <- nft
    }

    // Reveal a specified Template in a Set.
    pub fun revealTemplate(
      templateID: UInt64,
      metadata: {TemplateMetadata},
      salt: [UInt8]
    ) {
      pre {
        templateID < UInt64(self.templates.length)
          : ""templateId does not exist in Set.""
        self.templates[templateID].mintID != nil
          : ""Template has not been marked as minted.""
      }
      let template = &self.templates[templateID] as &Template
      template.reveal(metadata: metadata, salt: salt)

      let display = metadata.display()
      emit NFTRevealed(
        nftID: template.mintID!,
        setID: self.id,
        templateID: templateID,
        displayName: display.name,
        displayDescription: display.description,
        displayURI: display.thumbnail.uri(),
        metadata: metadata.repr(),
      )
    }

    init(id: UInt64, metadata: SetMetadata) {
      self.id = id
      self.metadata = metadata

      self.isLocked = false
      self.templates = []

      self.minted = 0
      emit SetCreated(setID: id, metadata: metadata)
    }
  }

  // Create and store a new Set. Return the id of the new Set.
  access(contract) fun createSet(metadata: SetMetadata): UInt64 {
    let setID = SNKRHUDNFT.totalSets

    let newSet <- create Set(
      id: setID,
      metadata: metadata
    )
    SNKRHUDNFT.sets[setID] <-! newSet
    SNKRHUDNFT.totalSets = SNKRHUDNFT.totalSets + 1
    return setID
  }

  // Number of sets created by contract
  pub fun setsCount(): UInt64 {
    return SNKRHUDNFT.totalSets
  }

  // Metadata for the Set
  pub struct SetMetadata {
    pub var name: String
    pub var description: String
    pub var externalID: String

    init(name: String, description: String, externalID: String) {
      self.name = name
      self.description = description
      self.externalID = externalID
    }
  }

  // A summary report of a Set
  pub struct SetReport {
    pub let id: UInt64
    pub let isLocked: Bool
    pub let metadata: SetMetadata
    pub let numTemplates: Int
    pub let numMinted: UInt64
    init(
      id: UInt64,
      isLocked: Bool,
      metadata: SetMetadata,
      numTemplates: Int,
      numMinted: UInt64
    ) {
      self.id = id
      self.isLocked = isLocked
      self.metadata = metadata
      self.numTemplates = numTemplates
      self.numMinted = numMinted
    }
  }

  // Generate a SetReport for informational purposes (to be used with scripts)
  pub fun generateSetReport(setID: UInt64): SetReport {
    let setRef = &self.sets[setID] as &Set
    return SetReport(
      id: setID,
      isLocked: setRef.isLocked,
      metadata: setRef.metadata,
      numTemplates: setRef.templates.length,
      numMinted: setRef.minted
    )
  }

  // Template
  //
  // Templates are mechanisms for handling NFT metadata. These should ideally
  // have a one to one mapping with NFTs, with the assumption that NFTs are
  // designed to be unique. Template allows the creator to commit to an NFTs
  // metadata without having to reveal the metadata itself. The constructor
  // accepts a byte array checksum. After construction, anyone with access
  // to this struct will be able to reveal the metadata, which must be any
  // struct which implements TemplateMetadata and MetadataViews.Resolver such that
  // SHA3_256(salt || metadata.hash()) == checksum.
  //
  // Templates can be seen as metadata managers for NFTs. As such, Templates
  // also implement the MetadataResolver interface to conform with standards.

  // Safe Template interface for anyone inspecting NFTs
  pub struct interface NFTTemplate {
    pub let defaultDisplay: MetadataViews.Display
    pub var metadata: {TemplateMetadata}?
    pub var mintID: UInt64?
    pub fun checksum(): [UInt8]
    pub fun salt(): [UInt8]?
    pub fun revealed(): Bool
    pub fun getViews(): [Type]
    pub fun resolveView(_ view: Type): AnyStruct?
  }

  pub struct Template: NFTTemplate {

    // checksum as described above
    access(self) let _checksum: [UInt8]

    // Default Display in case the Template has not yet been revealed
    pub let defaultDisplay: MetadataViews.Display

    // salt and metadata are optional so they can be revealed later, such that
    // SHA3_256(salt || metadata.hash()) == checksum
    access(self) var _salt: [UInt8]?
    pub var metadata: {TemplateMetadata}?

    // Convenience attribute to mark whether or not Template has minted NFT
    pub var mintID: UInt64?

    // Helper function to check if a proposed metadata and salt reveal would
    // produce the configured checksum in a Template
    pub fun validate(metadata: {TemplateMetadata}, salt: [UInt8]): Bool {
      let hash = String.encodeHex(
        HashAlgorithm.SHA3_256.hash(
          salt.concat(metadata.hash())
        )
      )
      let checksum = String.encodeHex(self.checksum())
      return hash == checksum
    }

    // Reveal template metadata and salt. validate() is called as a precondition
    // so collector can be assured metadata was not changed
    pub fun reveal(metadata: AnyStruct{TemplateMetadata}, salt: [UInt8]) {
      pre {
        self.mintID != nil
          : ""Template has not yet been minted.""
        !self.revealed()
          : ""NFT Template has already been revealed""
        self.validate(metadata: metadata, salt: salt)
          : ""salt || metadata.hash() does not hash to checksum""
      }
      self.metadata = metadata
      self._salt = salt
    }

    pub fun checksum(): [UInt8] {
      return self._checksum
    }

    pub fun salt(): [UInt8]? {
      return self._salt
    }

    // Check to see if metadata has been revealed
    pub fun revealed(): Bool {
      return self.metadata != nil
    }

    // Mark the NFT as minted
    pub fun markMinted(nftID: UInt64) {
      self.mintID = nftID
    }

    // Implements MetadataResolver.getViews
    pub fun getViews(): [Type] {
      if (!self.revealed()) {
        return [Type<MetadataViews.Display>()]
      }
      return self.metadata!.getViews()
    }

    // Implements MetadataResolver.resolveView
    pub fun resolveView(_ view: Type): AnyStruct? {
      if (!self.revealed()) {
        if (view != Type<MetadataViews.Display>()) {
          return nil
        }
        return self.defaultDisplay
      }
      return self.metadata!.resolveView(view)
    }

    init(checksum: [UInt8], defaultDisplay: MetadataViews.Display) {
      self._checksum = checksum
      self.defaultDisplay = defaultDisplay

      self._salt = nil
      self.metadata = nil
      self.mintID = nil
    }
  }

  // Public helper function to be able to inspect any Template
  pub fun getTemplate(setID: UInt64, templateID: UInt64): {NFTTemplate} {
    let setRef = &self.sets[setID] as &Set
    return setRef.templates[templateID]
  }

  pub resource SetMinter {
    pub let setID: UInt64

    init(setID: UInt64) {
      self.setID = setID
    }

    pub fun mint(templateID: UInt64, creator: Address): @NFT {
      let set = &SNKRHUDNFT.sets[self.setID] as &Set
      return <- set.mint(templateID: templateID, creator: creator)
    }
  }

  // Admin
  //
  // The Admin is meant to be a singleton superuser of the contract. The Admin
  // is responsible for creating Sets and SetManagers for managing the sets.
  pub resource Admin {

    // Create a set with the provided SetMetadata.
    pub fun createSet(metadata: SetMetadata): UInt64 {
      return SNKRHUDNFT.createSet(metadata: metadata)
    }

    pub fun borrowSet(setID: UInt64): &Set {
      return &SNKRHUDNFT.sets[setID] as &Set
    }

    pub fun createSetMinter(setID: UInt64): @SetMinter {
      return <- create SetMinter(setID: setID)
    }
  }

  // Contract constructor
  init() {

    // Collection Paths
    self.CollectionStoragePath = /storage/SNKRHUDNFTCollection
    self.CollectionPublicPath = /public/SNKRHUDNFTCollection
    self.CollectionPrivatePath = /private/SNKRHUDNFTCollection

    // Admin Storage Path. Save the singleton Admin resource to contract
    // storage.
    self.AdminStoragePath = /storage/SNKRHUDNFTAdmin
    self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)

    // Initializations
    self.totalSupply = 0
    self.totalSets = 0
    self.sets <- {}

    emit ContractInitialized()
  }
}
"
A.0000000000000000.SNKRHUDNFTPrimarySaleMinter,"import NonFungibleToken from 0x1d7e57aa55817448
import GaiaPrimarySale from 0x01ddf82c652e36ef
import SNKRHUDNFT from 0x80af1db15aa6535a

pub contract SNKRHUDNFTPrimarySaleMinter {
    pub resource Minter: GaiaPrimarySale.IMinter {
        access(self) let setMinter: @SNKRHUDNFT.SetMinter

        pub fun mint(assetID: UInt64, creator: Address): @NonFungibleToken.NFT {
            return <- self.setMinter.mint(templateID: assetID, creator: creator)
        }

        init(setMinter: @SNKRHUDNFT.SetMinter) {
            self.setMinter <- setMinter
        }

        destroy() {
            destroy self.setMinter
        }
    }

    pub fun createMinter(setMinter: @SNKRHUDNFT.SetMinter): @Minter {
        return <- create Minter(setMinter: <- setMinter)
    }
}
"
